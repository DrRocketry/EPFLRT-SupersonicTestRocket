/*
 * HoneywellRscWrapper.h
 *
 *  Created on: 2021-04-26
 *      Author: Joshua Cayetano-Emond
 */

#pragma once

// Standard libraries
#include <Arduino.h>

// External libraries
#include <Honeywell_RSC.h>

// User-defined headers
#include "Packet.hpp"
#include "Sensor.hpp"

// *************** HoneywellRsc Packets *************** //

/// Describe the content of a HoneywellRSC packet
struct HoneywellRSCBody
{
  float measurement = 0; ///< Using floats since the computation is hard to do after acquistion; 4 bytes
};

#define HoneywellRSC_BODY_TEMP_FORMAT "************** HoneywellRSC Packet *************\n" \
                                      "Temperature: %12e\n"                                \
                                      "***************** END OF PACKET ****************\n"

#define HoneywellRSC_BODY_PRESSURE_FORMAT "************** HoneywellRSC Packet *************\n" \
                                          "Pressure: %12e\n"                                   \
                                          "***************** END OF PACKET ****************\n"

/**
 * @brief Both HoneywellRSC_BODY_TEMP_FORMAT and HoneywellRSC_BODY_PRESSURE_FORMAT
 *        have 3 lines, with the opening and closing ones being 50 chars
 *        (null char included)
 */
#define HoneywellRSC_BODY_PRINT_SIZE 50 * 3

/**
 * @brief Packets generated by HoneywellRSC sensors, both for pressure and temperature
 *
 */
class HoneywellRSCPacket : public Packet
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new HoneywellRSCPacket, still abstract type
   *
   * \c packetSize is accordingly set, \c packetType_ is still to be defined.
   * Packet::content is allocated
   *
   * @see Packet::Packet()
   */
  HoneywellRSCPacket()
  {
    header.packetType_ = NO_PACKET;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  // ----- Getters ----- //

  /**
   * @brief Get the float contained in the packet
   *
   * @return float
   */
  float getMeasurement()
  {
    return reinterpret_cast<HoneywellRSCBody *>(content)->measurement;
  }

  // ----- Setters ----- //

  /**
   * @brief Set the float contained in the packet
   *
   * @param m Provided value
   */
  void setMeasurement(float m)
  {
    reinterpret_cast<HoneywellRSCBody *>(content)->measurement = m;
  }
};

/**
 * @brief HoneywellRSC Temperature packet
 *
 */
class HoneywellRSC_Temp_Packet : public HoneywellRSCPacket
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new HoneywellRSC_Temp_Packet based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  HoneywellRSC_Temp_Packet()
  {
    header.packetType_ = RSC_TEMP_PACKET_TYPE;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new HoneywellRSC_Temp_Packet from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  HoneywellRSC_Temp_Packet(PacketHeader h)
  {
    assert(h.packetType_ == RSC_TEMP_PACKET_TYPE &&
           h.packetSize == sizeof(HoneywellRSCBody));

    header = h;
    content = malloc(h.packetSize);
  }

  /**
   * @brief Return a pointer toward a printable description of an HoneywellRSC Pressure content
   *
   * @return char* : Pointer toward formated content description
   */
  char *getPrintableContent()
  {
    char output[HoneywellRSC_BODY_PRINT_SIZE] = "";

    snprintf(output, HoneywellRSC_BODY_PRINT_SIZE, HoneywellRSC_BODY_PRESSURE_FORMAT,
             getMeasurement());

    return output;
  }
};

class HoneywellRSC_Pressure_Packet : public HoneywellRSCPacket
{
public:
  // ----- Constructors ----- //
  /**
   * @brief Construct a new HoneywellRSC_Pressure_Packet based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  HoneywellRSC_Pressure_Packet()
  {
    header.packetType_ = RSC_PRESSURE_PACKET_TYPE;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new HoneywellRSC_Pressure_Packet from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  HoneywellRSC_Pressure_Packet(PacketHeader h)
  {
    assert(h.packetType_ == RSC_PRESSURE_PACKET_TYPE &&
           h.packetSize == sizeof(HoneywellRSCBody));

    header = h;
    content = malloc(h.packetSize);
  }

  /**
   * @brief Return a pointer toward a printable description of an HoneywellRSC Temperature content
   *
   * @return char* : Pointer toward formated content description
   */
  char *getPrintableContent()
  {
    char output[HoneywellRSC_BODY_PRINT_SIZE] = "";

    snprintf(output, HoneywellRSC_BODY_PRINT_SIZE, HoneywellRSC_BODY_TEMP_FORMAT,
             getMeasurement());

    return output;
  }
};

// *************** HoneywellRscWrapper class *************** //

/**
 * @brief Wrapper for HoneywellRsc sensors
 *
 */
class HoneywellRscWrapper : public Sensor
{
private:
  /**
   * @brief How often temperature measurements will be made.
   *        Every nth measurement will be a temperature measurement.
   */
  int temp_frequency;

  int measurementAmountModulo = 0; ///< Number of measurements modulo HoneywellRscWrapper::temp_frequency

  // sensor min/max values for error checking
  float pressureMax = 15;                ///< TODO: add unit
  float pressureMin = 0;                 ///< TODO: add unit
  static constexpr float TEMP_MAX = 85;  ///< TODO: add unit
  static constexpr float TEMP_MIN = -40; ///< TODO: add unit

  Honeywell_RSC rscObject; ///< Underlying object
  static uint8_t sensorQty; ///< How many sensors of this type exist

  HoneywellRSC_Pressure_Packet lastPressurePacket; ///< Holder for the pressure packet, actualized by measurements
  HoneywellRSC_Temp_Packet lastTempPacket; ///< Holder for the temperature packet, actualized by measurements
  HoneywellRSCPacket *lastPackets[2]; ///< Holder for HoneywellRscWrapper::lastPressurePacket and HoneywellRscWrapper::lastTempPacket pointers (in that order)

  // Parameters for setup
  RSC_DATA_RATE data_rate;///< Desired data rate provided to HoneywellRscWrapper::rscObject at initialization
  uint32_t desiredTempPeriod; ///< TODO: Look at how effective it is

public:
  // constructor
  HoneywellRscWrapper(int DR, int CS_EE, int CS_ADC, int SPI_BUS,
                      RSC_DATA_RATE data_r, uint32_t desired_P);

  // destructor
  ~HoneywellRscWrapper();

  // attemps to set up the sensor and returns true if it was successful
  bool setup(uint32_t attempts, uint32_t delayDuration);

  const char *myName() { return "HoneywellRsc"; }

  // return the current count of sensors
  uint8_t getSensorQty();

  // check if the sensor is due for a measurement
  bool isDue(uint32_t currMicros, volatile bool &triggeredDR);

  // overwritten version of method in base class sensor
  bool isMeasurementInvalid();

  // determine current reading type
  READING_T currReadType();

  // determine next reading type
  READING_T nextReadType();

  HoneywellRSCPacket *getPacket(uint32_t currMicros);
  HoneywellRSCPacket **getSerialPackets(uint32_t currMicros);

  PacketHeader getHeader(uint32_t currMicros);
};