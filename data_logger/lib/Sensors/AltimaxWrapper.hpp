/*
 * AltimaxWrapper.hpp
 *
 *  Created on: 2021-11-20
 *      Author: Joshua Cayetano-Emond
 */

#pragma once

// Standard libraries
#include <Arduino.h>

// User-defined headers
#include "Packet.hpp"
#include "Sensor.hpp"

// *************** Altimax Packets *************** //

/// Describe the content of a Altimax pakcet
struct AltimaxBody
{
  /**
   * Altimax has 3 pins that can output data
   * The 4th boolean is to ensure proper structure alignment (Teensy is 32-bit)
   * 4 * 1 = 4 bytes
   */
  bool pinStates[4] = {0};
};

#define Altimax_BODY_FORMAT "************** AltimaxBody Packet **************\n" \
                            "PIN 0 Status: %2d\n"                                \
                            "PIN 1 Status: %2d\n"                                \
                            "PIN 2 Status: %2d\n"                                \
                            "***************** END OF PACKET ****************\n"

/**
 * @brief Altimax_BODY_FORMAT has 5 lines,
 *        with the opening and closing ones being 50 chars long
 *        (null char included)
 */
#define Altimax_BODY_PRINT_SIZE 50 * 5

/**
 * @brief Packet generated by Altimax sensors
 *
 */
class AltimaxPacket : public Packet
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new AltimaxPacket based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  AltimaxPacket()
  {
    header.packetType_ = ALTIMAX_PACKET_TYPE;
    header.packetSize = sizeof(AltimaxBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new AltimaxPacket from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  AltimaxPacket(PacketHeader h)
  {
    assert(h.packetType_ == ALTIMAX_PACKET_TYPE &&
           h.packetSize == sizeof(AltimaxBody));

    header = h;
    content = malloc(h.packetSize);
  }

  // ----- Getters ----- //

  /**
   * @brief Get the status of pin 0
   *
   * @return bool
   */
  bool getPin0state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[0];
  }

  /**
   * @brief Get the status of pin 1
   *
   * @return bool
   */
  bool getPin1state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[1];
  }

  /**
   * @brief Get the status of pin 2
   *
   * @return bool
   */
  bool getPin2state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[2];
  }

  /**
   * @brief Given an array of 3 bools, fill it with the values of pins 0,1,2
   *
   * @param states Array to be filled
   */
  void getPinsState(bool states[3])
  {
    states[0] = getPin0state();
    states[1] = getPin1state();
    states[2] = getPin2state();
  }

  /**
   * @brief Fill the given \p buffer with a printable description of the packet's content
   *
   */
  void getPrintableContent(char *buffer)
  {

    snprintf(buffer, Altimax_BODY_PRINT_SIZE, Altimax_BODY_FORMAT,
             getPin0state(),
             getPin1state(),
             getPin2state());
  }

  // ----- Setters ----- //

  /**
   * @brief Given an array of 3 bools, set the values for pins 0,1,2
   *
   * @param states Source array
   */
  void setPinsState(bool states[3])
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[0] = states[0];
    reinterpret_cast<AltimaxBody *>(content)->pinStates[1] = states[1];
    reinterpret_cast<AltimaxBody *>(content)->pinStates[2] = states[2];
  }

  /**
   * @brief Set the state for pin 0
   *
   * @param state0
   */
  void setPin0state(bool state0)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[0] = state0;
  }

  /**
   * @brief Set the state for pin 1
   *
   * @param state0
   */
  void setPin1state(bool state1)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[1] = state1;
  }

  /**
   * @brief Set the state for pin 2
   *
   * @param state0
   */
  void setPin2state(bool state2)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[2] = state2;
  }

  /**
   * @brief Set the whole content of the packet
   *
   * @param b
   */
  void setContent(AltimaxBody b)
  {
    memcpy(content, static_cast<void *>(&b), sizeof(AltimaxBody));
  }
};

// *************** AltimaxWrapper class *************** //

/**
 * @brief Wrapper for Altimax sensors
 * These sensor announce preset events; they should be checked only when DR line is up
 */
class AltimaxWrapper : public Sensor
{
private:
  static uint8_t sensorQty; ///< How many sensors of this type exist

  AltimaxPacket lastPacket; ///< Underlying object

  const uint8_t PIN_0; ///< Index for Pin 0
  const uint8_t PIN_1; ///< Index for Pin 1
  const uint8_t PIN_2; ///< Index for Pin 2

public:
  // constructor
  AltimaxWrapper(uint8_t PIN_0_, uint8_t PIN_1_, uint8_t PIN_2_);

  // destructor
  ~AltimaxWrapper();

  // attemps to set up the sensor and returns true if it was successful
  bool setup(uint32_t attempts, uint32_t delayDuration);

  const char *myName() { return "Altimax"; }

  // return the current count of sensors
  uint8_t getSensorQty();

  // check if the sensor is due for a measurement
  bool isDue(uint32_t currMicros, volatile bool &triggeredDR);

  // overwritten version of method in base class sensor
  bool isMeasurementInvalid();

  AltimaxPacket *getPacket(uint32_t currMicros);

  PacketHeader getHeader(uint32_t currMicros);
};