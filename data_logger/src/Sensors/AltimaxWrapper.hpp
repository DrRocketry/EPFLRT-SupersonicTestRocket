/*
 * AltimaxWrapper.hpp
 *
 *  Created on: 2021-11-20
 *      Author: Joshua Cayetano-Emond
 */

#pragma once

// Standard libraries
#include <Arduino.h>

// User-defined headers
#include "Packet.hpp"
#include "Sensor.hpp"

#include "PacketBody/AltimaxBody.h"

// *************** Altimax Packets *************** //

#define Altimax_LINE_0 "PIN 0 Status: %2d\n"
#define Altimax_LINE_1 "PIN 1 Status: %2d\n"
#define Altimax_LINE_2 "PIN 2 Status: %2d\n"
#define Altimax_LINE_NBR 2

/**
 * @brief Altimax_BODY_FORMAT has 5 lines,
 *        with the opening and closing ones being 50 chars long
 *        (null char included)
 */
#define Altimax_BODY_PRINT_SIZE 50 * 5

/**
 * @brief Packet generated by Altimax sensors
 *
 */
class AltimaxPacket : public Packet
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new AltimaxPacket based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  AltimaxPacket()
  {
    header.packetType_ = ALTIMAX_PACKET_TYPE;
    header.packetSize = sizeof(AltimaxBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new AltimaxPacket from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  AltimaxPacket(PacketHeader h)
  {
    assert(h.packetType_ == ALTIMAX_PACKET_TYPE &&
           h.packetSize == sizeof(AltimaxBody));

    header = h;
    content = malloc(h.packetSize);
  }

  // ----- Getters ----- //

  /**
   * @brief Get the status of pin 0
   *
   * @return bool
   */
  bool getPin0state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[0];
  }

  /**
   * @brief Get the status of pin 1
   *
   * @return bool
   */
  bool getPin1state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[1];
  }

  /**
   * @brief Get the status of pin 2
   *
   * @return bool
   */
  bool getPin2state()
  {
    return reinterpret_cast<AltimaxBody *>(content)->pinStates[2];
  }

  /**
   * @brief Given an array of 3 bools, fill it with the values of pins 0,1,2
   *
   * @param states Array to be filled
   */
  void getPinsState(bool states[3])
  {
    states[0] = getPin0state();
    states[1] = getPin1state();
    states[2] = getPin2state();
  }

  /**
   * @brief Fill \p buffer with the \p lineNbr line of content to be displayed
   *
   * If the line queried does not exist ( \p lineNbr too big), does nothing to \p buffer
   *
   * @param buffer Buffer to be filled (with up to DATA_SIZE chars)
   * @param lineNbr Number of the queried line
   * @return int : 1 if there are lines after \p lineNbr , 0 otherwise
   */
  int getPrintableContent(char *buffer, size_t lineNbr)
  {
    switch (lineNbr)
    {
    case 0:
      snprintf(buffer, DATA_SIZE, Altimax_LINE_0, getPin0state());
      return 1;

    case 1:
      snprintf(buffer, DATA_SIZE, Altimax_LINE_1, getPin1state());
      return 1;

    case 2:
      snprintf(buffer, DATA_SIZE, Altimax_LINE_2, getPin2state());
      return 0;

    default:
      return 0;
    }
  }

  /**
   * @brief Write AltimaxBody in Big Endian style in \p buffer
   * 
   * @warning Move \p buffer past the data
   * 
   * @param buffer Buffer of size at least packetSize
   */
  void getBigEndian(void *buffer)
  {
    uint8_t* reBuffer = (uint8_t*)buffer;

    // Booleans are not endian-sensitive
    *(reBuffer++) = getPin0state();
    *(reBuffer++) = getPin1state();
    *(reBuffer++) = getPin2state();
  }

  // ----- Setters ----- //

  /**
   * @brief Given an array of 3 bools, set the values for pins 0,1,2
   *
   * @param states Source array
   */
  void setPinsState(bool states[3])
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[0] = states[0];
    reinterpret_cast<AltimaxBody *>(content)->pinStates[1] = states[1];
    reinterpret_cast<AltimaxBody *>(content)->pinStates[2] = states[2];
  }

  /**
   * @brief Set the state for pin 0
   *
   * @param state0
   */
  void setPin0state(bool state0)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[0] = state0;
  }

  /**
   * @brief Set the state for pin 1
   *
   * @param state0
   */
  void setPin1state(bool state1)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[1] = state1;
  }

  /**
   * @brief Set the state for pin 2
   *
   * @param state0
   */
  void setPin2state(bool state2)
  {
    reinterpret_cast<AltimaxBody *>(content)->pinStates[2] = state2;
  }

  /**
   * @brief Set the whole content of the packet
   *
   * @param b
   */
  void setContent(AltimaxBody b)
  {
    memcpy(content, static_cast<void *>(&b), sizeof(AltimaxBody));
  }
};

// *************** AltimaxWrapper class *************** //

/**
 * @brief Wrapper for Altimax sensors
 * These sensor announce preset events; they should be checked only when DR line is up
 */
class AltimaxWrapper : public Sensor
{
private:
  static uint8_t sensorQty; ///< How many sensors of this type exist

  const uint8_t PIN_0; ///< Index for Pin 0
  const uint8_t PIN_1; ///< Index for Pin 1
  const uint8_t PIN_2; ///< Index for Pin 2

  AltimaxPacket lastPacket; ///< Underlying object

public:
  // constructor
  AltimaxWrapper(uint8_t PIN_0_, uint8_t PIN_1_, uint8_t PIN_2_);

  // destructor
  ~AltimaxWrapper();

  // attemps to set up the sensor and returns true if it was successful
  bool setup(uint32_t attempts, uint32_t delayDuration);

  const char *myName() { return "Altimax"; }

  // return the current count of sensors
  uint8_t getSensorQty();

  // check if the sensor is due for a measurement
  bool isDue(uint32_t currMicros, volatile bool &triggeredDR);

  // overwritten version of method in base class sensor
  bool isMeasurementInvalid();

  AltimaxPacket *getPacket();

  PacketHeader getHeader(uint32_t currMicros);
};