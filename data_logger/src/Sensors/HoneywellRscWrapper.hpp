/*
 * HoneywellRscWrapper.h
 *
 *  Created on: 2021-04-26
 *      Author: Joshua Cayetano-Emond
 */

#pragma once

// Standard libraries
#include <Arduino.h>

// External libraries
#include <Honeywell_RSC.h>

// User-defined headers
#include "Packet.hpp"
#include "Sensor.hpp"
#include "globalVariables.hpp"
#include "macrofunctions.h"

#include "HoneywellRscBody.h"

// *************** HoneywellRsc Packets *************** //

#define HoneywellRSC_TEMP_LINE "Temperature: %6e Â°C\n"
#define HoneywellRSC_PRESSURE_LINE "Pressure: %6e bar\n"

#define HoneywellRSC_LINE_NBR 0

/**
 * @brief Both HoneywellRSC_BODY_TEMP_FORMAT and HoneywellRSC_BODY_PRESSURE_FORMAT
 *        have 3 lines, with the opening and closing ones being 50 chars
 *        (null char included)
 */
#define HoneywellRSC_BODY_PRINT_SIZE 50 * 3

/**
 * @brief Packets generated by HoneywellRSC sensors, both for pressure and temperature
 *
 */
class HoneywellRSCPacket : public Packet
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new HoneywellRSCPacket, still abstract type
   *
   * \c packetSize is accordingly set, \c packetType_ is still to be defined.
   * Packet::content is allocated
   *
   * @see Packet::Packet()
   */
  HoneywellRSCPacket()
  {
    header.packetType_ = NO_PACKET;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  // ----- Getters ----- //

  /**
   * @brief Get the float contained in the packet
   *
   * @return float
   */
  float getMeasurement()
  {
    return reinterpret_cast<HoneywellRSCBody *>(content)->measurement;
  }

  /**
   * @brief Write HoneywellRSCBody in Big Endian style in \p buffer
   * 
   * @warning Move \p buffer past the data
   * 
   * @param buffer Buffer of size at least packetSize
   */
  void getBigEndian(void *buffer)
  {
    uint8_t* reBuffer = (uint8_t*)buffer;
    float meas = getMeasurement();

    BIG_ENDIAN_WRITE(meas,reBuffer);
  }

  // ----- Setters ----- //

  /**
   * @brief Set the float contained in the packet
   *
   * @param m Provided value
   */
  void setMeasurement(float m)
  {
    reinterpret_cast<HoneywellRSCBody *>(content)->measurement = m;
  }
};

/**
 * @brief HoneywellRSC Temperature packet
 *
 */
class HoneywellRSC_Temp_Packet : public HoneywellRSCPacket
{
public:
  // ----- Constructors ----- //

  /**
   * @brief Construct a new HoneywellRSC_Temp_Packet based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  HoneywellRSC_Temp_Packet()
  {
    header.packetType_ = RSC_TEMP_PACKET_TYPE;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new HoneywellRSC_Temp_Packet from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  HoneywellRSC_Temp_Packet(PacketHeader h)
  {
    assert(h.packetType_ == RSC_TEMP_PACKET_TYPE &&
           h.packetSize == sizeof(HoneywellRSCBody));

    header = h;
    content = malloc(h.packetSize);
  }

  /**
   * @brief Fill \p buffer with the \p lineNbr line of content to be displayed
   *
   * If the line queried does not exist ( \p lineNbr too big), does nothing to \p buffer
   *
   * @param buffer Buffer to be filled (with up to DATA_SIZE chars)
   * @param lineNbr Number of the queried line
   * @return int : 1 if there are lines after \p lineNbr , 0 otherwise
   */
  int getPrintableContent(char *buffer, size_t lineNbr)
  {
    switch (lineNbr)
    {
    case 0:
      snprintf(buffer, DATA_SIZE, HoneywellRSC_TEMP_LINE, getMeasurement());
      return 0;

    default:
      return 0;
    }
  }
};

class HoneywellRSC_Pressure_Packet : public HoneywellRSCPacket
{
public:
  // ----- Constructors ----- //
  /**
   * @brief Construct a new HoneywellRSC_Pressure_Packet based on the default header
   *
   * \c packetType_ and \c packetSize are accordingly set.
   * Packet::content is allocated.
   *
   * @see Packet::Packet()
   */
  HoneywellRSC_Pressure_Packet()
  {
    header.packetType_ = RSC_PRESSURE_PACKET_TYPE;
    header.packetSize = sizeof(HoneywellRSCBody);

    content = malloc(header.packetSize);
  }

  /**
   * @brief Construct a new HoneywellRSC_Pressure_Packet from a given header
   *
   * Set the header to the one provided and allocate memory according the the size
   * indicated in the header
   *
   * @param h Header for the packet, must have correct size and type
   */
  HoneywellRSC_Pressure_Packet(PacketHeader h)
  {
    assert(h.packetType_ == RSC_PRESSURE_PACKET_TYPE &&
           h.packetSize == sizeof(HoneywellRSCBody));

    header = h;
    content = malloc(h.packetSize);
  }

  /**
   * @brief Fill \p buffer with the \p lineNbr line of content to be displayed
   *
   * If the line queried does not exist ( \p lineNbr too big), does nothing to \p buffer
   *
   * @param buffer Buffer to be filled (with up to DATA_SIZE chars)
   * @param lineNbr Number of the queried line
   * @return int : 1 if there are lines after \p lineNbr , 0 otherwise
   */
  int getPrintableContent(char *buffer, size_t lineNbr)
  {
    switch (lineNbr)
    {
    case 0:
      snprintf(buffer, DATA_SIZE, HoneywellRSC_PRESSURE_LINE, getMeasurement());
      return 0;

    default:
      return 0;
    }
  }
};

// *************** HoneywellRscWrapper class *************** //

/**
 * @brief Wrapper for HoneywellRsc sensors
 *
 */
class HoneywellRscWrapper : public Sensor
{
private:
  /**
   * @brief How often temperature measurements will be made.
   *        Every nth measurement will be a temperature measurement.
   */
  int temp_frequency;

  int measurementAmountModulo = 0; ///< Number of measurements modulo HoneywellRscWrapper::temp_frequency

  // sensor min/max values for error checking
  float pressureMax = 15;                ///< [bar]
  float pressureMin = 0;                 ///< [bar]
  static constexpr float TEMP_MAX = 85;  ///< [degC]
  static constexpr float TEMP_MIN = -40; ///< [degC]

  Honeywell_RSC rscObject;  ///< Underlying object
  static uint8_t sensorQty; ///< How many sensors of this type exist

  HoneywellRSC_Pressure_Packet lastPressurePacket; ///< Holder for the pressure packet, actualized by measurements
  HoneywellRSC_Temp_Packet lastTempPacket;         ///< Holder for the temperature packet, actualized by measurements
  HoneywellRSCPacket *lastPackets[2];              ///< Holder for HoneywellRscWrapper::lastPressurePacket and HoneywellRscWrapper::lastTempPacket pointers (in that order)

  // Parameters for setup
  RSC_DATA_RATE data_rate;    ///< Desired data rate provided to HoneywellRscWrapper::rscObject at initialization
  uint32_t desiredTempPeriod; ///< TODO: Look at how effective it is

public:
  // constructor
  HoneywellRscWrapper(int DR, int CS_EE, int CS_ADC, int SPI_BUS,
                      RSC_DATA_RATE data_r, uint32_t desired_P);

  // destructor
  ~HoneywellRscWrapper();

  // attemps to set up the sensor and returns true if it was successful
  bool setup(uint32_t attempts, uint32_t delayDuration);

  const char *myName() { return "HoneywellRsc"; }

  // return the current count of sensors
  uint8_t getSensorQty();

  // check if the sensor is due for a measurement
  bool isDue(uint32_t currMicros, volatile bool &triggeredDR);

  // overwritten version of method in base class sensor
  bool isMeasurementInvalid();

  // determine current reading type
  READING_T currReadType();

  // determine next reading type
  READING_T nextReadType();

  HoneywellRSCPacket *getPacket(uint32_t currMicros);
  HoneywellRSCPacket **getSerialPackets(uint32_t currMicros);

  PacketHeader getHeader(uint32_t currMicros);
};