
// IMPORT LIBRARIES ============================================================
// Standard libraries
#include <SPI.h>

// ADIS16470 Arduino Teensy
// https://github.com/juchong/ADIS16470_Arduino_Teensy
#include <ADIS16470.h>

// SdFat
// https://github.com/greiman/SdFat
// Also available from the library manager.
#include <SdFat.h>
#include <RingBuf.h>

// DEFINE VARIABLES ============================================================


// Timing ----------------------------------------------------------------------
// I/O events. Defined as pairs of button states and durations
const int LOG_ON_STATE = 1;  // State to turn on logging
const unsigned long LOG_ON_DURATION = 1 * 1000 * 1000;        // [us]
const int LOG_OFF_SEQ1_STATE = 1; // State to initiate log off sequence
const unsigned long LOG_OFF_SEQ1_DURATION = 3 * 1000 * 1000;  // [us]
const int LOG_OFF_SEQ2_STATE = 0; // State to continue log off sequence
const unsigned long LOG_OFF_SEQ2_DURATION = 5 * 1000 * 1000;  // [us]
const int LOG_OFF_SEQ3_STATE = 2; // State to finish log off sequence
const unsigned long LOG_OFF_SEQ3_DURATION = 7 * 1000 * 1000;  // [us]
const unsigned long IO_MARGIN = 1 * 1000 * 1000;              // [us]

const int AIS1120SX_LOG_INTERVAL = 2500;                      // [us]
const int TC_LOG_INTERVAL = 500;                       // [us]
const int FLUSH_INTERVAL = 100 * 1000;                        // [us]



// File logging ----------------------------------------------------------------
// Use Teensy SDIO
#define SD_CONFIG  SdioConfig(FIFO_SDIO)

// Size to log 32 byte lines at 2000Hz for more than sixty minutes.
#define LOG_FILE_SIZE 32*2000*60
// Space to hold 32 byte lines at 2000Hz for more than 1000ms.
#define RING_BUF_CAPACITY 32*2000*1

SdFs sd;
FsFile counterFile;

// Counter for the logging file name
#define COUNTER_FILENAME "counter.dat"
uint16_t counterVal = 0;

// ADIS16470 IMU ---------------------------------------------------------------
// Call ADIS16470 Class
ADIS16470 IMU(CS_ADIS16470_PIN, DR_ADIS16470_PIN, RST_ADIS16470_PIN);
uint8_t *IMUburstData; // Temporary Data Array

// AIS1120SX Accelerometer -----------------------------------------------------

// Pressure sensors ------------------------------------------------------------

// Thermocouples ---------------------------------------------------------------

// Data structures -------------------------------------------------------------

struct datastore {
  unsigned long timestamp;
  float gyroX;
  float gyroY;
  float gyroZ;
  float accX;
  float accY;
  float accZ;
  float accZ_onboard;
  float accZ_altimeter;
  float total_pressure;
  float static_pressure;
  float static_pressure_altimeter;
  float T1;
  float T2;
  float T3;
  float T4;
};
struct datastore myData;

struct smallerstore {
  unsigned long timestamp;
  float gyroX;
  float gyroY;
  float gyroZ;
  float accX;
  float accY;
  float accZ;
  float accZ_onboard;
};
struct smallerstore myData2;


// USER FUNCTIONS ==============================================================


void logData() {
  // INITIALIZATION
  // Open or create counter file.
  if (!counterFile.open(COUNTER_FILENAME, O_RDWR | O_CREAT)) {
    Serial.println("open counter file failed\n");
    return;
  }

  // if the file is not empty, get the current count
  // else start at zero
  if (counterFile.size() != 0) {
    counterFile.read(&counterVal, 2);
    counterFile.seek(0); // return to beginning so we don't append to file
  }

  // get the name of the logging file
  char fileName[16];
  snprintf(fileName, sizeof(fileName), "%06d.dat", counterVal);

  // write the count for the next logging file
  counterVal++;
  counterFile.write((const uint8_t *)&counterVal, 2);
  counterFile.close();

  // Open or create logging file.
  FsFile loggingFile;
  if (!loggingFile.open(fileName, O_RDWR | O_CREAT | O_TRUNC)) {
    Serial.println("open logging file failed\n");
    return;
  }

  // File must be pre-allocated to avoid huge
  // delays searching for free clusters.
  if (!loggingFile.preAllocate(LOG_FILE_SIZE)) {
    Serial.println("preAllocate failed\n");
    loggingFile.close();
    return;
  }

  // initialize the RingBuf.
  RingBuf<FsFile, RING_BUF_CAPACITY> rb;
  rb.begin(&loggingFile);

  // Max RingBuf used bytes. Useful to understand RingBuf overrun.
  size_t maxUsed = 0;

  // Min spare micros in loop.
  unsigned long minSpareMicros = INT32_MAX;

  // Start time.
  unsigned long previousLogLoop = micros();
  unsigned long nextFlushLoop = micros();

  // Save data into the RingBuf.
  //rb.write((const uint8_t *)&myData, sizeof(myData));

  /

    unsigned long spareMicros = previousLogLoop + TC_LOG_INTERVAL - micros();
    if (micros() - previousLogLoop >= TC_LOG_INTERVAL) {


      // Read data from all of the sensors.
      // Done next to one another to be as simultaneous as possible.

      // Put the data into the structure
      myData2.timestamp = micros();
      myData2.gyroX = random();
      myData2.gyroY = random();
      myData2.gyroZ = random();
      myData2.accX = random();
      myData2.accY = random();
      myData2.accZ = random();
      myData2.accZ_onboard = random();

      // Save data into the RingBuf.
      rb.write((const uint8_t *)&myData2, sizeof(myData2));

      if (rb.getWriteError()) {
        // Error caused by too few free bytes in RingBuf.
        Serial.println("WriteError");
        break;
      }


      // Time for next point.
      previousLogLoop += TC_LOG_INTERVAL;
      spareMicros = previousLogLoop + TC_LOG_INTERVAL - micros();
      if (spareMicros < minSpareMicros) {
        minSpareMicros = spareMicros;
      }
      Serial.print(micros());
      Serial.print(", ");
      Serial.print(previousLogLoop);
      Serial.print(", ");
      Serial.print(spareMicros);
      Serial.print(", ");
      Serial.println(minSpareMicros);
      if (spareMicros >= 10000000) {
        Serial.print("Rate too fast ");
        Serial.println(spareMicros);
        break;
      }
    } // measurement if statement

    // Flush the sd card if it's been long enough
    if (micros() - nextFlushLoop >= FLUSH_INTERVAL) {
      nextFlushLoop += FLUSH_INTERVAL; // restart the flush timer
      rb.sync();
      Serial.print("Just flushed. Spare micros: ");
      Serial.println(spareMicros);
    }

    //    // Read from the AIS1120SX if it's been long enough
    //    if (micros() - nextAISLoop > 0) {
    //      loggingFile.flush();
    //      nextFlushLoop += FLUSH_INTERVAL; // restart the flush timer
    //    }

    // See if data is ready for the ADIS16470
    //    // Read IMU burst data and point to data array without checksum
    //    IMUburstData = IMU.byteBurst();

    // See if data is ready for the pressure sensors


    // Check if ringBuf is ready for writing
    // Amount of data in ringBuf.
    size_t n = rb.bytesUsed();
    // See if the file is full
    if ((n + loggingFile.curPosition()) > (LOG_FILE_SIZE - 20)) {
      Serial.println("File full - quiting.");
      break;
    }
    // Update maximum  used buffer size. For buffer overflow issues
    if (n > maxUsed) {
      maxUsed = n;
    }
    if (n >= 512 && !loggingFile.isBusy()) {
      // Not busy only allows one sector before possible busy wait.
      // Write one sector from RingBuf to file.
      if (512 != rb.writeOut(512)) {
        Serial.println("writeOut failed");
        break;
      }
    }

  } // logging while loop

  // Write any RingBuf data to file.
  rb.sync();
  loggingFile.truncate();
  loggingFile.rewind();
  loggingFile.close();
  digitalWrite(LED2_PIN, LOW);

}